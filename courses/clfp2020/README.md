# Мова Common Lisp: вступ до функціонального програмування

У цьому курсі розглядаються основні принципи функціонального підходу
до програмування, його переваги та недоліки, а також елементи
математичного апарату, на якому він базується. В якості основного
інструменту використовуєтся мова програмування *Common Lisp*.




## Практика

### Лабораторна робота №1 - підготовка середовища розробки

Однією з традиційних особливостей мов програмування з сімейства *Lisp*
є те, що практично всі компоненти сучасного інтергрованого середовища
розробки програмного забезпечення (*IDE*) є "вбудованими" в
компілятор. Типове середовище *Lisp* - це інтерактивний інструмент під
назвою **REPL** (*Read-Eval-Print Loop*), що може читати, компілювати
та виконувати код, введений користувачем, автоматично переходячи в
режим дебагу при виникненні помилки. Багато сучасних мов
програмування, зокрема *Python*, використовують спрощені версії
подібних середовищ для екпериментів та прототипування, але дуже мало з
них можуть навіть наблизитись за функціональністю до *REPL*-середовищ
популярних компіляторів *Common Lisp*, в першу чергу через систему
обробки помилок, що передбачена стандартом мови.

Дана лабораторна робота полягає у налаштуванні середовища *Common
Lisp*, що складається з компілятора, текстового редактора та адаптера
для взаємодії між редактором та компілятором. Ми використовуватимемо
відкритий компілятор **SBCL**, який на даний момент є найращим
безкоштовним компілятором *Common Lisp*, текстовий редактор **Emacs**,
який вже кілька десятиліть є одним з найпопулярніших текстових
редакторів у світі, та плагін для *Emacs* під назвою **SLIME**, який і
є адаптером між текстовим редактором та компілятором.

#### Встановлення програмного забезпечення

Для встановлення *SBCL* та *Emacs* 26.2 на операційну систему *Linux*
необхідно виконати наступні команди (приклади наведено для
дистрибутиву Ubuntu):

``` bash
# Додаткові пакети
sudo apt install git
# SBCL
sudo apt install sbcl
# Emacs
sudo apt-add-repository ppa:kelleyk/emacs
sudo apt update
sudo apt install emacs26
```

На *macOS* *Emacs* можна встановити, виконавши наступну команду:

``` bash
# SBCL
brew intall sbcl
# Emacs
brew cask install emacs
```

Для операційної системи *Windows* *SBCL* та *Emacs* можна завантажити
за посиланнями
http://prdownloads.sourceforge.net/sbcl/sbcl-2.0.0-x86-64-windows-binary.msi
та
https://ftp.gnu.org/gnu/emacs/windows/emacs-26/emacs-26.1-x86_64.zip
відповідно. Для запуску редактора необхідно виконати файл
`bin\runemacs.exe`. Зверніть увагу на те, що для налаштування адаптера
необхідно знати шлях, за яким було встановлено компілятор.

Після того, як втановлення *SBCL* та *Emacs* завершено, необхідно
встановити плагін *SLIME*. Це можна зробити самостійно відповідно до
[інструкцій](https://github.com/slime/slime), або скористатись файлом
`.emacs` у даній директорії, який необхідно розмістити у "домашній"
директорії на робочому комп'ютері (`/home/<username>/.emacs` на
*Linux*, `/Users/<username>/.emacs` на *macOS* та
`%HOMEPATH%\AppData\Roaming\.emacs` на *Windows*). У випадку з Windows
необхідно у цьому файлі замінити змінну `inferior-lisp-program` на
шлях, за яким було встановлено компілятор *SBCL*. Можна помітити, що
конфігурація та розширення (розробка плагінів) текстового редактора
*Emacs* здійснюється за допомогою діалекта *Lisp* під назвою *Emacs
Lisp* або *Elisp*.

При запуску *Emacs* встановить всі необхідні компоненти і відкриє файл
під назвою `*scratch*`, який є спеціальною "чернеткою" для нотаток та
налаштувань. Після цього можна потестувати налаштування середовища,
натиснувши комбінацію клавіш `Alt+x` для переходу в режим команд і
виконати команду `slime`, яка запустить компілятор *SBCL*, налаштує
адаптер та покаже рядок введення *REPL*:

``` cl
CL-USER>

```

У цьому вікні редактора можна безпосередньо вводити, редагувати,
компілювати та виконувати програмний код *Common Lisp*.

#### Docker

Всі описані вище кроки зібрані у вигляді рецепту Docker (файл
`Dockerfile` у даній директорії), тому за наявності налаштованого
середовища *Docker* можна просто зібрати *Docker*-образ та запустити
середовище *Common Lisp* у контейнері *Docker*:

``` bash
docker build -t lisp .
docker run -it --rm lisp emacs
```

#### Захист лабораторної роботи

Для захисту лабораторної роботи необхідно продемонструвати запуск та
зупинку робочого *REPL*-середовища, виконати кілька простих
арифметичних обчислень а також оголосити будь-яку арифметичну функцію
від 2-х і більше параметрів та, викликавши її, отримати очікуваний
результат.


### Лабораторна робота №2 - основи програмування мовою *Common Lisp*

У даній лабораторній роботі необхідно реалізувати 3 типи асоціативних
структур даних:

- `associative-list` - список, що містить `cons`-пари `(<ключ>
  . <значення>)` (приклад: `((:a . 1) (:b . 2) (:c . 3))`);
- `property-list` - список, що містить парну кількість елементів, де
  непарні елементи є ключами, а парні - значеннями (приклад: `(:a 1 :b
  2 :c 3)`);
- `binary-tree` - бінарне дерево пошуку, що в якості ключів
  використовує символи - їх можна порівнювати лексикографічно за
  допомогою функцій `string<`, `string>`
  [тощо](http://www.lispworks.com/documentation/HyperSpec/Body/f_stgeq_.htm).

Для кожної структури даних потрібно реалізувати 2 функції - додавання
нової асоціації та пошуку значення за ключем:

``` cl
# Associative list
(defun associative-list-add (list key value)
  ...)

(defun associative-list-get (list key)
  ...)

# Property list
(defun property-list-add (list key value)
  ...)

(defun property-list-get (list key)
  ...)

# Binary list
(defun binary-tree-add (tree key value)
  ...)

(defun binary-tree-get (tree key)
  ...)
```

Функція додавання нової асоціації повинна повертати конструювати та
повертати нову структуру. Наприклад, для додавання нової пари `(ключ,
значення)` в асоціативний список необхідно присвоїти результат функції
якійсь змінній, інакше його буде втрачено:

``` cl
CL-USER> (let ((list '()))
           (setf (associative-list-add list :a 1))
           list)
((:a . 1))
```

Функція пошуку значення за ключем повинна повертати два значення - сам
елемент, що відповіє ключу, або `nil`, якщо такого ключа немає, та
маркер `t` або `nil`, що вказує на присутність чи відсутність ключа
відповідно (аналогічно до того, як працює функція пошуку в хеш-таблиці
`gethash`):

``` cl
CL-USER> (defvar *list* '())
*LIST*

CL-USER> (setf *list* (associative-list-add *list* :a 1))
((:a . 1))

CL-USER> (associative-list-get *list* :a)
1
T

CL-USER> (associative-list-get *list* :b)
NIL
NIL
```


#### Захист лабораторної роботи

Для захисту лабораторної роботи необхідно для кожної з реалізованих
структур даних створити змінну з порожньою структурою, додати кілька
елементів і здійснити пошук за існуючим та неіснуючим ключами. Окрім
цього необхідно продемонструвати створення непорожньої структури даних
(з одним-двома елементами) без використання функції додавання
асоціації для демонстрації розуміння спискової структури структури
(тавтологія невипадкова :)).




## Ресурси

Для поглибленого вивчення матеріалу, що розглядається в даному курсі,
рекомендую наступні ресурси:

1. [*Common Lisp
   Hyperspec*](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm) -
   (майже) повний текст стандарту *Common Lisp* у відкритому
   доступі. Пошук по даному ресурсу можна здійснювати безпосередньо з
   *Emacs* (при ввімкненому режимі *SLIME*), за допомогою комбінації
   клавіш `C-c h` - сторінка з сайту буде відображена безпосередньо в
   текстовому редакторі.

2. [*Structure and Interpretation of Computer
   Programs*](https://www.youtube.com/watch?v=2Op3QLzMgSY) -
   відеозапис курсу лекцій, прочитаного Гелом Абельсоном та Джеральдом
   Джеєм Сасманом в Массачусетському технологічному інституті 1986
   року. Курс використовує мінімалістичний та елегантний діалект
   *Lisp* під назвою *Scheme* і до цього часу вважається одним з
   найкращих курсів про основи побудови комп'ютерних програм. Курс
   супроводжується книгою тих же авторів, що знаходиться у [відкритому
   доступі](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html).
